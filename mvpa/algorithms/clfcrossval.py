#emacs: -*- mode: python-mode; py-indent-offset: 4; indent-tabs-mode: nil -*-
#ex: set sts=4 ts=4 sw=4 et:
### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ##
#
#   See COPYING file distributed along with the PyMVPA package for the
#   copyright and license terms.
#
### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ##
"""Cross-validate a classifier on a dataset"""

__docformat__ = 'restructuredtext'

import numpy as N

from copy import copy

from mvpa.algorithms.datameasure import DataMeasure
from mvpa.datasets.splitter import NoneSplitter
from mvpa.clfs.transerror import ConfusionMatrix
from mvpa.misc import warning
from mvpa.misc.state import StateVariable

if __debug__:
    from mvpa.misc import debug

class ClfCrossValidation(DataMeasure):
    """Cross validate a classifier on datasets generated by a splitter from a
    source dataset.

    Arbitrary performance/error values can be computed by specifying an error
    function (used to compute an error value for each cross-validation fold)
    and a combiner function that aggregates all computed error values across
    cross-validation folds.
    """

    results = StateVariable(enabled=False, doc=
       """Store individual results in the state""")
    splits = StateVariable(enabled=False, doc=
       """Store the actual splits of the data. Can be memory expensive""")
    transerrors = StateVariable(enabled=False, doc=
       """Store copies of transerrors at each step""")
    confusions = StateVariable(enabled=False, doc=
       """Store actual confusion matrices (if available)""")
    confusion = StateVariable(enabled=False, doc=
       """Store total confusion matrix (if available)""")

    def __init__(self,
                 transerror,
                 splitter=NoneSplitter(),
                 combinerfx=N.mean,
                 **kwargs):
        """
        Cheap initialization.

        :Parameters:
            transerror : TransferError instance
                Provides the classifier used for cross-validation.
            splitter : Splitter instance
                Used to split the dataset for cross-validation folds. By
                convention the first dataset in the tuple returned by the
                splitter is used to train the provided classifier. If the
                first element is 'None' no training is performed. The second
                dataset is used to generate predictions with the (trained)
                classifier.
            combinerfx : Functor
                Used to aggregate the error values of all cross-validation
                folds.
        """
        DataMeasure.__init__(self, **kwargs)

        self.__splitter = splitter
        self.__transerror = transerror
        self.__combinerfx = combinerfx



# TODO: put back in ASAP
#    def __repr__(self):
#        """String summary over the object
#        """
#        return """ClfCrossValidation /
# splitter: %s
# classifier: %s
# errorfx: %s
# combinerfx: %s""" % (indentDoc(self.__splitter), indentDoc(self.__clf),
#                      indentDoc(self.__errorfx), indentDoc(self.__combinerfx))


    def __call__(self, dataset, callbacks=[]):
        """Perform cross-validation on a dataset.

        'dataset' is passed to the splitter instance and serves as the source
        dataset to generate split for the single cross-validation folds.
        """
        # store the results of the splitprocessor
        results = []

        self.splits = []
        self.confusion = ConfusionMatrix()
        self.confusions = []
        self.transerrors = []

        # splitter
        for split in self.__splitter(dataset):
            # only train classifier if splitter provides something in first
            # element of tuple -- the is the behavior of TransferError
            if self.states.isEnabled("splits"):
                self.splits.append(split)

            result = self.__transerror(split[1], split[0])

            if self.states.isEnabled("transerrors"):
                self.transerrors.append(copy(self.__transerror))

            if self.states.isEnabled('confusions'):
                if self.__transerror.states.isActive('confusion'):
                    self.confusions.append(self.__transerror.confusion)
                else:
                    warning("Crossvalidator %s can't store confusions state " %
                            self +
                            "since transfer error %s " %
                            self.__transerror +
                            "doesn't have confusion enabled to registered")

            if self.states.isEnabled('confusion'):
                if self.__transerror.states.isActive('confusion'):
                    self.confusion += self.__transerror.confusion
                else:
                    warning("Crossvalidator %s can't store confusion state " %
                            self +
                            "since transfer error %s " %
                            self.__transerror +
                            "doesn't have confusion enabled to registered")


            if __debug__:
                debug("CROSSC", "Split #%d: result %s" \
                      % (len(results), `result`))
            results.append(result)

            # XXX add callbacks

        self.results = results
        """Store state variable if it is enabled"""

        return self.__combinerfx(results)


    splitter = property(fget=lambda self:self.__splitter)
    transerror = property(fget=lambda self:self.__transerror)
    combinerfx = property(fget=lambda self:self.__combinerfx)
