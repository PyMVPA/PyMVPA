#!/usr/bin/env python
# emacs: -*- mode: python; py-indent-offset: 4; indent-tabs-mode: nil -*-
# vi: set ft=python sts=4 ts=4 sw=4 et:
### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ##
#
#   See COPYING file distributed along with the PyMVPA package for the
#   copyright and license terms.
#
### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ##
"""Helper to automagically generate ReST versions of examples"""

__docformat__ = 'restructuredtext'


import os
import sys
import re
import glob
from optparse import OptionParser
from warnings import warn

def proc_example(filename, opts):
    #  doc filename
    dfilename = os.path.basename(filename[:-3]) + '.rst'

    # open source file
    xfile = open(filename)
    # open dest file
    dfile = open(os.path.join(opts.outdir, os.path.basename(dfilename)), 'w')

    # place header
    dfile.write('.. AUTO-GENERATED FILE -- DO NOT EDIT!\n\n')

    # place cross-ref target
    dfile.write('.. _example_' + dfilename[:-4] + ':\n\n')

    # parser status vars
    inheader = True
    indocs = False
    doc2code = False
    code2doc = False
    # an empty line found in the example enables the check for a potentially
    # indented docstring starting on the next line (as an attempt to exclude
    # function or class docstrings)
    last_line_empty = False
    # indentation of indented docstring, which is removed from the RsT output
    # since we typically do not want an indentation there.
    indent_level = 0

    for line in xfile:
        # skip header
        if inheader and not line.startswith('"""'):
            continue
        # determine end of header
        if inheader and line.startswith('"""'):
            inheader = False

        # strip comments and remove trailing whitespace
        if not indocs and last_line_empty:
            # first remove leading whitespace and store indent level
            cleanline = line[:line.find('#')].lstrip()
            indent_level = len(line) - len(cleanline) - 1
            cleanline = cleanline.rstrip()
        else:
            cleanline = line[:line.find('#')].rstrip()

        if not indocs and line == '\n':
            last_line_empty = True
        else:
            last_line_empty = False

        # if we have something that should go into the text
        if indocs or cleanline.startswith('"""'):
            proc_line = None
            # handle doc start
            if not indocs:
                # guarenteed to start with """
                if len(cleanline) > 3 and cleanline.endswith('"""'):
                    # single line doc
                    code2doc = True
                    doc2code = True
                    proc_line = cleanline[3:-3]
                else:
                    # must be start of multiline block
                    indocs = True
                    code2doc = True
                    # rescue what is left on the line
                    proc_line = cleanline[3:] # strip """
            else:
                # we are already in the docs
                # handle doc end
                if cleanline.endswith('"""'):
                    indocs = False
                    doc2code = True
                    # rescue what is left on the line
                    proc_line = cleanline[:-3]
                    # reset the indentation
                    indent_level = 0
                else:
                    # has to be documentation
                    proc_line = line[indent_level:]

            if code2doc:
                code2doc = False
                dfile.write('\n')

            if proc_line:
                dfile.write(proc_line.rstrip() + '\n')

        else:
            if doc2code:
                doc2code = False
                dfile.write('\n')

                # if there is nothing on the line, do nothing
                if not line.strip():
                    continue

            # has to be code
            dfile.write('  >>> ' + line)

    if opts.sourceref:
        # write post example see also box
        dfile.write("\n.. seealso::\n  The full source code of this example is "
                    "included in the %s source distribution (`%s`).\n"
                    % (opts.project, filename))

    xfile.close()
    dfile.close()



def main():
    parser = OptionParser( \
        usage="%prog [options] <filename|directory> [...]", \
        version="%prog 0.1", description="""\
%prog does ...
""" )

    # define options
    parser.add_option('--verbose', action='store_true', dest='verbose',
                      default=False, help='print status messages')
    parser.add_option('-x', '--exclude', action='append', dest='excluded',
                      help="""\
""" )
    parser.add_option('-o', '--outdir', action='store', dest='outdir',
                      type='string', default=None, help="""\
""" )
    parser.add_option('--no-sourceref', action='store_false', default=True,
                      dest='sourceref', help="""\
""" )
    parser.add_option('--project', type='string', action='store', default='',
                      dest='project', help="""\
Name of the project that contains the examples. This name is used in the
'seealso' source references. Default: ''
""" )

    # parse options
    (opts, args) = parser.parse_args() # read sys.argv[1:] by default

    # check for required options
    if opts.outdir is None:
        print('Required option -o, --outdir not specified.')
        sys.exit(1)

    # build up list of things to parse
    toparse = []
    for t in args:
        # expand dirs
        if os.path.isdir(t):
            # add all python files in that dir
            toparse += glob.glob(os.path.join(t, '*.py'))
        else:
            toparse.append(t)

    # filter parse list
    if not opts.excluded is None:
        toparse = [t for t in toparse if not t in opts.excluded]

    toparse_list = toparse
    toparse = set(toparse)

    if len(toparse) != len(toparse_list):
        print('Ignoring duplicate parse targets.')

    if not os.path.exists(opts.outdir):
        os.mkdir(outdir)

    # finally process all examples
    for t in toparse:
        proc_example(t, opts)


if __name__ == '__main__':
    main()
